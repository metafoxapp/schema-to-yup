{"version":3,"file":"index.js","sources":["../src/types/schema-parser-maps/json-schema.js","../src/types/schema-parser-maps/type-def.js","../src/types/schema-parser-maps/avro.js","../src/types/schema-parser-maps/index.js","../src/types/_type-matcher.js","../src/types/_loggable.js","../src/types/schema-parser-builder.js","../src/types/base.js","../src/conditions/when/when-entry.js","../src/conditions/when/when-condition.js","../src/constraint-builder.js","../src/error-message-handler.js","../src/types/mixed/mixed.js","../src/types/mixed/defaults.js","../src/types/array/array.js","../src/types/array/handler.js","../src/types/array/index.js","../src/types/boolean/boolean.js","../src/types/boolean/handler.js","../src/types/boolean/index.js","../src/types/constraints/base.js","../src/types/constraints/numeric.js","../src/types/number/range-constraint.js","../src/types/_guard.js","../src/types/number/guard.js","../src/types/number/index.js","../src/types/object/object.js","../src/types/object/handler.js","../src/types/object/index.js","../src/types/string/string.js","../src/types/string/handler.js","../src/types/string/index.js","../src/types/date/date.js","../src/types/date/handler.js","../src/types/date/index.js","../src/base-property-value-resolver.js","../src/multi-property-value-resolver.js","../src/single-property-value-resolver.js","../src/property-value-resolver.js","../src/entry.js","../src/create-entry.js","../src/yup-builder.js","../src/validator-bridge/index.js"],"sourcesContent":["const defaults = {\n  getProps: obj => obj && obj.properties,\n  getType: obj => obj && obj.type,\n  getName: obj => obj && (obj.name || obj.title),\n  getConstraints: obj => obj,\n  isString: obj => obj && obj.type === \"string\",\n  isArray: obj => obj && obj.type === \"array\",\n  isInteger: obj => obj && (obj.type === \"integer\" || obj.type === \"int\"),\n  isBoolean: obj => obj && obj.type === \"boolean\",\n  hasDateFormat: obj =>\n    obj && [\"date\", \"date-time\"].find(t => t === obj.format),\n  isDate: obj =>\n    obj && obj.type === \"string\" && defaults.hasDateFormat(obj.format),\n  isNumber: obj => obj && (obj.type === \"number\" || defaults.isInteger(obj)),\n  isObject: obj => obj && obj.type === \"object\",\n  isRequired: obj => obj && obj.required\n};\n\nexport default defaults;\n","const typeDefConf = {\n  getProps: (obj) => obj.properties,\n  getType: (obj) => obj.type,\n  getName: (obj) => obj.name || obj.title,\n  getConstraints: (obj) => obj,\n  isString: (obj) => obj.type === \"string\" && !typeDefConf.hasDateFormat(obj),\n  isArray: (obj) => obj.type === \"array\",\n  isBoolean: (obj) => obj.type === \"boolean\",\n  isInteger: (obj) => obj.type === \"integer\",\n  hasDateFormat: (obj) => [\"date\", \"date-time\"].includes(obj?.value?.format), // using nullish coalescing\n  isDate: (obj) => obj.type === \"string\" && typeDefConf.hasDateFormat(obj),\n  isNumber: (obj) => obj.type === \"number\" || typeDefConf.isInteger(obj),\n  isObject: (obj) => obj.type === \"object\",\n  isRequired: (obj) => obj.required,\n};\n\nconst defaults = typeDefConf;\n// {\n//   getProps: obj => obj && obj.fields,\n//   getType: obj => obj && obj.type,\n//   getName: obj => obj && obj.name,\n//   getConstraints: obj => (obj && (obj.directives || {}).constraints) || {},\n//   isString: obj => obj && obj.type === \"String\",\n//   isArray: obj => obj && obj.isList,\n//   isInteger: obj => obj && obj.type === \"Int\",\n//   isBoolean: obj => obj && obj.type === \"Boolean\",\n//   isDate: obj => (obj && obj.type === \"Date\") || obj.directives.date,\n//   isNumber: obj => (obj && obj.type === \"Int\") || obj.type === \"Float\",\n//   isObject: obj => obj && obj.type === \"Object\",\n//   isRequired: obj => obj && !obj.isNullable\n// };\n\nexport default defaults;\n","// see https://avro.apache.org/docs/current/spec.html\n\nconst defaults = {\n  getProps: obj => obj && obj.fields,\n  getType: obj => obj && obj.type,\n  getName: obj => obj && (obj.name || obj.title),\n  getConstraints: obj => obj,\n  isString: obj => obj && obj.type === \"string\",\n  isArray: obj => obj && obj.type === \"array\",\n  isInteger: obj => obj && obj.type === \"int\",\n  isFloat: obj => obj && obj.type === \"float\",\n  isDouble: obj => obj && obj.type === \"double\",\n  isBoolean: obj => obj && obj.type === \"boolean\",\n  isDate: obj =>\n    obj && obj.type === \"int\" && obj.logicalType === \"date\",\n  isNumber: obj => obj && (defaults.isInteger(obj) || defaults.isFloat(obj) || defaults.isDouble(obj)),\n  isObject: obj => obj && obj.type === \"record\",\n  isRequired: obj => obj && obj.required\n};\n\nexport default defaults;\n","import jsonSchemaDefaults from \"./json-schema\";\nimport typeDefDefaults from \"./type-def\";\nimport avroDefaults from \"./avro\";\n\nconst defaults = {\n  \"json-schema\": jsonSchemaDefaults,\n  \"type-def\": typeDefDefaults,\n  \"avro\": avroDefaults\n};\n\nexport default defaults","import { Loggable } from \"./_loggable\";\n\nclass TypeMatcher extends Loggable {\n  constructor(config = {}) {\n    super(config);\n  }\n\n  isNothing(val) {\n    return val === undefined || val === null;\n  }\n\n  isPresent(num) {\n    return !this.isNothing(num);\n  }\n\n  toNumber(num) {\n    return Number(num);\n  }\n\n  isNumberLike(num) {\n    return !isNaN(this.toNumber(num));\n  }\n\n  isObjectType(obj) {\n    return obj === Object(obj);\n  }\n\n  isArrayType(value) {\n    return Array.isArray(value);\n  }\n\n  isNumberType(num) {\n    return !isNaN(num);\n  }\n\n  isStringType(val) {\n    return typeof val === \"string\";\n  }\n\n  isFunctionType(val) {\n    return typeof val === \"function\";\n  }\n\n  isDateType(val) {\n    return val instanceof Date;\n  }\n}\n\nexport { TypeMatcher };\n","class Loggable {\n  constructor(config = {}) {\n    this.config = config;\n    const { log, error } = config;    \n    const enable = config.enable || {};\n    if (config.logging === true) {\n      enable.log = true\n    }\n    if (config.logging === false) {\n      enable.log = false\n    }\n    this.enable = enable;\n    // what type of logger to use\n    this.log = typeof log === \"function\" ? log : console.log;\n    this.err = typeof error === \"function\" ? error : console.error;\n  }\n\n  error(errMsg, ...values) {\n    // only disable if directly disabled\n    if (this.enable.error === false) return;\n    if (!this.err) return\n    values && values.length ? this.err(errMsg, ...values) : this.err(errMsg);\n    throw errMsg;\n  }\n\n  warn(warnMsg, ...values) {\n    if (!this.enable.warn) return;\n    this.logInfo(\"WARNING: \" + warnMsg, ...values);\n  }\n\n  logInfo(name, ...values) {\n    if (!this.enable.log) return;\n    if (!this.log) return\n    values && values.length ? this.log(name, ...values) : this.log(name);\n  }\n}\n\nexport { Loggable };\n","export const createSchemaParserBuilder = (schemaParserMap, schemaType) => {\n  return new SchemaParserBuilder(schemaParserMap, schemaType)\n}\n\nexport class SchemaParserBuilder {\n  constructor(schemaParserMap, name) {\n    this.schemaParserMap = schemaParserMap\n    this.name = name\n  }\n\n  lookup(name = this.name) {\n    return this.schemaParserMap[name]\n  }  \n\n  build() {\n    const entry = this.lookup();\n    if (entry.extends) {\n      const result = this.extend(entry.extends)\n      if (result) return result\n    }\n    return entry\n  }\n\n  extend(name) {\n    const baseMap = this.lookup(name)\n    if (!baseMap) return \n    entry = {\n      ...baseMap,\n      ...this.lookup()\n    }\n  }\n}","import defaultSchemaParserMap from \"./schema-parser-maps\";\n// import { createYupSchemaEntry } from '../create-entry';\nimport { TypeMatcher } from \"./_type-matcher\";\nimport { createSchemaParserBuilder } from './schema-parser-builder'\n\nclass Base extends TypeMatcher {\n  constructor(config = {}) {\n    super(config);\n    const schemaType = config.schemaType || \"json-schema\";\n    const schemaParserMap = config.schemaParserMap || defaultSchemaParserMap\n    const builder = config.createSchemaParserBuilder || createSchemaParserBuilder(schemaParserMap, schemaType)\n    const schemaParser = builder.build();\n    this.config = { ...schemaParser, ...config };\n  }\n\n  createSchemaParserBuilder(schemaParserMap, schemaType) {\n    return new SchemaParserBuilder(schemaParserMap, schemaType)\n  }\n}\n\nexport { Base };\n","function isObjectType(obj) {\n    return obj === Object(obj);\n}\n\nfunction isStringType(val) {\n    return typeof val === 'string';\n}\n\nexport class WhenEntry {\n    constructor(whenEntryObj, opts = {}) {\n        this.whenEntryObj = whenEntryObj;\n        const { schema, properties, config, key, keys, when, type } = opts;\n        this.schema = schema;\n        this.when = when;\n        this.properties = properties || {};\n        this.key = key;\n        // this.whenKeys = (when ? Object.keys(when) : keys) || [];\n        this.type = type;\n        this.config = config;\n    }\n\n    // keysArePresent(keys) {\n    //   const whenKeys = this.whenKeys;\n    //   return keys.every(key => !!whenKeys.includes(key));\n    // }\n\n    validateAndConfigure(whenEntryObj) {\n        whenEntryObj = whenEntryObj || this.whenEntryObj;\n        if (!isObjectType(whenEntryObj)) {\n            this.warn(\n                'invalid or missing when entry constraint object',\n                whenEntryObj\n            );\n            return false;\n        }\n\n        const whenEntryKeys = Object.keys(whenEntryObj);\n\n        if (whenEntryKeys.length < 2) {\n            this.warn(\n                `validateAndConfigure: when entry constraint must have at least 2 keys: ${whenEntryKeys}`,\n                whenEntryObj\n            );\n            return false;\n        }\n\n        // must have is condition\n        if (!this.hasKey(whenEntryKeys, 'is')) {\n            this.warn(\n                `validateAndConfigure: when entry constraint missing 'is' constraint: ${whenEntryKeys}`,\n                whenEntryObj\n            );\n            return false;\n        }\n\n        // must have then condition\n        if (!this.hasKey(whenEntryKeys, 'then')) {\n            this.warn(\n                `validateAndConfigure: when entry constraint missing 'then' or 'else' constraint: ${whenEntryKeys}`,\n                whenEntryObj\n            );\n            return false;\n        }\n\n        // this.whenEntryKeys = this.keys || [];\n        // this.whenEntryKeysPresent = this.keysArePresent(this.whenEntryKeys);\n\n        return true;\n    }\n\n    createYupSchemaEntry(opts) {\n        return this.config.createYupSchemaEntry(opts);\n    }\n\n    createValue(entryObj, key) {\n        if (typeof entryObj === 'string') {\n            entryObj = {\n                [entryObj]: true\n            };\n        }\n        if (!isObjectType(entryObj)) {\n            this.error(`createValue: ${key} must be a schema object`);\n        }\n        return {\n            key: this.key,\n            type: this.type,\n            ...entryObj\n        };\n    }\n\n    createEntryOpts(entryObj, whenKey) {\n        // recursive apply then object\n        const value = this.createValue(entryObj, whenKey);\n        return {\n            schema: this.schema,\n            properties: this.properties,\n            key: this.key,\n            type: this.type,\n            value,\n            config: this.config\n        };\n    }\n\n    createEntry(entryObj, whenKey) {\n        const opts = this.createEntryOpts(entryObj, whenKey);\n        return this.createYupSchemaEntry(opts);\n    }\n\n    hasKey(keys, findKey) {\n        return keys.find(key => key === findKey);\n    }\n\n    hasAnyKey(keys, findKeys) {\n        return keys.find(key => findKeys.includes(key));\n    }\n\n    // checkIs(is, present) {\n    //   present = present || this.whenEntryKeysPresent;\n    //   const checked = (is === true && present) || (is === false && !present);\n    //   // const keys = this.whenEntryKeys;\n    //   return checked;\n    // }\n\n    whenEntryFor(whenObj, createEntryKey, whenKey) {\n        whenKey = whenKey || createEntryKey;\n\n        if (isStringType(whenObj)) {\n            whenObj = {\n                [whenObj]: true\n            };\n        }\n\n        if (!isObjectType(whenObj)) {\n            throw `whenEntryFor: Invalid when object ${whenObj}`;\n        }\n\n        // clone\n        const entryDef = {\n            ...whenObj[whenKey]\n        };\n        delete whenObj[whenKey];\n        if (!entryDef) return whenObj;\n        whenObj[createEntryKey] = this.createEntry(entryDef, createEntryKey);\n        return whenObj;\n    }\n\n    calcEntryObj() {\n        let newEntry = {\n            ...this.whenEntryObj\n        };\n        newEntry = this.whenEntryFor(newEntry, 'then');\n        if ('otherwise' in newEntry) {\n            newEntry = this.whenEntryFor(newEntry, 'otherwise');\n        }\n        if ('else' in newEntry) {\n            newEntry = this.whenEntryFor(newEntry, 'else');\n        }\n        return newEntry;\n    }\n\n    get entryObj() {\n        return this.validateAndConfigure() && this.calcEntryObj();\n    }\n\n    warn(msg, value) {\n        console.error('[WhenEntry] WARNING', msg, value);\n    }\n\n    error(msg, value) {\n        console.error('[WhenEntry] ERROR', msg, value);\n        throw msg;\n    }\n}\n\nexport const createWhenEntry = (whenEntry, opts = {}) => {\n    return new WhenEntry(whenEntry, opts);\n};\n","import { createWhenEntry } from \"./when-entry\";\n\nfunction isObjectType(obj) {\n  return obj === Object(obj);\n}\n\nfunction isStringType(val) {\n  return typeof val === \"string\";\n}\n\nclass WhenCondition {\n  constructor(opts = {}) {\n    const { type, key, value, when, schema, properties, config } = opts;\n    this.opts = opts;\n    this.when = when;\n    this.key = key;\n    this.type = type;\n    this.value = value;\n    this.schema = schema;\n    this.properties = properties;\n    this.config = config;\n    this.validate();\n  }\n\n  validate() {\n    if (!isStringType(this.type)) {\n      this.error(`validate: invalid or mising type: ${this.type}`, this.opts);\n    }\n\n    if (!isObjectType(this.when)) {\n      this.error(`validate: invalid or mising when: ${this.when}`, this.opts);\n    }\n  }\n\n  validateAndConfigure(when) {\n    when = when || this.when;\n    if (!isObjectType(when)) {\n      this.warn(\"invalid or missing when constraint\", when);\n      return false;\n    }\n\n    const whenKeys = Object.keys(when);\n\n    if (whenKeys.length < 1) {\n      this.warn(`when constraint must have at least 1 key: ${whenKeys}`, when);\n      return false;\n    }\n\n    this.whenKeys = whenKeys;\n    return true;\n  }\n\n  createWhenEntry(whenEntryObj, opts) {\n    return createWhenEntry(whenEntryObj, opts);\n  }\n\n  accumulate(acc, key) {\n    // clone\n    let whenEntryObj = this.when[key];\n\n    if (!isObjectType(whenEntryObj)) {\n      this.warn(\n        `invalid when entry constraint object ${whenEntryObj} for ${key}`\n      );\n      return acc;\n    }\n\n    // const keys = Object.keys(whenEntryObj);\n\n    const opts = {\n      // keys,\n      type: this.type,\n      key: this.key,\n      schema: this.schema,\n      properties: this.properties,\n      config: this.config\n    };\n\n    const { entryObj } = this.createWhenEntry(whenEntryObj, opts);\n    if (!entryObj) return acc;\n\n    acc = Object.assign(acc, entryObj);\n    return acc;\n  }\n\n  get constraintObj() {\n    if (!this.whenKeys) return {};\n    return this.whenKeys.reduce(this.accumulate.bind(this), {});\n  }\n\n  get keyVal() {\n    const keys = this.whenKeys || [];\n    return keys.length === 1 ? keys[0] : keys;\n  }\n\n  get constraintValue() {\n    return this.keyVal ? [this.keyVal, this.constraintObj] : false;\n  }\n\n  get constraint() {\n    return this.validateAndConfigure() && this.constraintValue;\n  }\n\n  warn(msg, value) {\n    console.error(\"[WhenCondition] WARNING\", msg, value);\n  }\n\n  error(msg, value) {\n    console.error(\"[WhenCondition] ERROR\", msg, value);\n    throw msg;\n  }\n}\n\nconst createWhenCondition = opts => {\n  return new WhenCondition(opts);\n};\n\nexport { WhenCondition, createWhenCondition };\n","import { TypeMatcher } from \"./types/_type-matcher\";\n\nexport class ConstraintBuilder extends TypeMatcher {\n  constructor(typeHandler, config = {}) {\n    super(config);\n    this.typeHandler = typeHandler\n    this.builder = typeHandler.builder\n    this.constraintsAdded = {};\n    this.delegators.map(name => {\n      this[name] = typeHandler[name];\n    });\n  }\n\n  get delegators() {\n    return [\"errMessages\", \"base\", \"key\", \"type\", \"constraints\", \"errorMessageHandler\", \"logInfo\", \"warn\"];\n  }\n\n  build(propName, opts = {}) {\n    let {\n      constraintName,\n      constraintValue,\n      propValue,\n      method,\n      yup,\n      value,\n      values,\n      errName\n    } = opts;\n    yup = yup || this.base; \n\n    // find the first value that is present (must not be undefined or null)   \n    const potentialValues = [constraintValue, propValue, this.constraints[propName]];\n    constraintValue = this.getFirstValue(potentialValues)\n      \n    constraintName = constraintName || propName;\n    method = method || constraintName;\n    this.idObj = {propName, method, key: this.key}\n\n    this.logDetailed(\"build\", opts, { resolved: { constraintValue, constraintName}})\n  \n    // this.logInfo(\"build\", { opts, constraintValue })\n\n    if (this.isNothing(constraintValue)) {\n      this.warn(\"no prop value\", { constraintValue });\n      return false;\n    }\n\n    const yupConstraintMethodName = this.aliasMap[method] || method;\n\n    if (!yup[yupConstraintMethodName]) {\n      const msg = `Yup has no such API method: ${yupConstraintMethodName}`;\n      this.warn(msg);\n      return false;\n    }\n\n    const constraintFn = yup[yupConstraintMethodName].bind(yup);\n\n    const constraintErrMsg = this.valErrMessage(constraintName);\n    const errErrMsg = errName && this.valErrMessage(errName);\n\n    const errFn = constraintErrMsg || errErrMsg;\n\n    const constrOpts = {\n      constraintName,\n      yup,\n      constraintFn,\n      errFn\n    };\n\n    const constrainFnNames = [\n      \"multiValueConstraint\",\n      \"presentConstraintValue\",\n      \"nonPresentConstraintValue\"\n    ];\n    let newBase;\n    for (let name of constrainFnNames) {\n      const fnName = this[name].bind(this)\n      const constrValue = this.getFirstValue([value, values])\n      newBase = fnName(constrValue, constrOpts);\n      if (newBase) break;\n    }\n\n    if (newBase) {\n      // const { _whitelist } = newBase;\n      // const list = _whitelist && _whitelist.list;\n      this.base = newBase;\n      return newBase;\n    }\n\n    this.warn(\"buildConstraint: missing value or values options\");\n    return false;\n  }\n\n  getFirstValue(potentialValues) {\n    const isDefined = this.isPresent.bind(this)\n    return potentialValues.filter(isDefined)[0]\n  }\n\n  nonPresentConstraintValue(\n    constraintValue,\n    { constraintName, constraintFn, errFn }\n  ) {\n    if (this.isPresent(constraintValue)) return;\n    this.logInfo(\"nonPresentConstraintValue\", { constraintValue })\n\n    this.onConstraintAdded({ method: 'nonPresentConstraintValue', name: constraintName });\n\n    const newBase = constraintFn(errFn);\n    return newBase;\n  }\n\n  presentConstraintValue(\n    constraintValue,\n    { constraintName, constraintFn, errFn }\n  ) {\n    if (!this.isPresent(constraintValue)) {\n      this.logInfo(\"presentConstraintValue: value not present\", { constraintName, constraintValue })\n      return;\n    }\n    this.logInfo(\"presentConstraintValue\", { constraintName, constraintValue })\n\n    this.onConstraintAdded({ method: 'presentConstraintValue', name: constraintName, value: constraintValue });\n\n    if (this.isNoValueConstraint(constraintName)) {\n      this.logInfo(\"isNoValueConstraint\", { constraintName })\n      let specialNewBase = constraintFn(errFn);\n      return specialNewBase;\n    }\n    this.logInfo(\"presentConstraintValue: apply validator function\", { constraintName, constraintValue })\n    const newBase = constraintFn(constraintValue, errFn);\n    return newBase;\n  }\n\n  multiValueConstraint(values, { constraintFn, constraintName, errFn }) {\n    if (!this.isPresent(values)) return;\n\n    this.logInfo(\"multiValueConstraint\", { constraintName, values })    \n    // call yup constraint function with multiple arguments\n    if (!Array.isArray(values)) {\n      this.warn(\"buildConstraint: values option must be an array of arguments\");\n      return;\n    }\n\n    this.onConstraintAdded({ method: 'multiValueConstraint', name: constraintName, value: values });\n    // console.log(constraintFn, { constraintName, values });\n    this.logInfo(\"multiValueConstraint: apply validator function\", { constraintName, value: values })\n\n    return this.callConstraintFn(constraintFn, constraintName, values, errFn);\n  }\n\n  callConstraintFn(constraintFn, constraintName, values, errFn) {\n    const isMulti = this.isMultiArgsCall(constraintName);\n    // console.log({ constraintName, isMulti });\n    // if (isMulti) {\n    //   console.log(constraintName, ...values);\n    // }\n    return isMulti\n      ? constraintFn(...values, errFn)\n      : constraintFn(values, errFn);\n  }\n\n  isMultiArgsCall(constraintName) {\n    return this.multiArgsValidatorMethods[constraintName];\n  }\n\n  get multiArgsValidatorMethods() {\n    return (\n      this.config.multiArgsValidatorMethods || {\n        when: true\n      }\n    );\n  }\n\n  isNoValueConstraint(constraintName) {\n    return this.noValueConstraints.includes(constraintName);\n  }\n\n  get noValueConstraints() {\n    return [\"required\", \"email\", \"url\", \"format\"];\n  }\n\n  addValueConstraint(propName, { constraintName, errName } = {}) {\n    return this.addConstraint(propName, {\n      constraintName,\n      value: true,\n      errName\n    });\n  }\n\n  addConstraint(propName, opts) {\n    const constraint = this.build(propName, opts);\n    if (constraint) {\n      this.typeHandler.base = constraint;\n      // const { _whitelist } = constraint;\n      // const list = _whitelist && _whitelist.list;\n      return constraint;\n    }\n    return false;\n  }\n\n  onConstraintAdded({ method, name, value }) {\n    this.constraintsAdded[name] = value;\n    if (!this.builder) {\n      this.logInfo('no builder set to notify in ConstraintBuilder')\n      return\n    }\n    this.builder.onConstraintAdded({ type: this.type, method, name, value })\n    return this.typeHandler;\n  }\n\n  get constraintsMap() {\n    return {\n      simple: [\"required\", \"notRequired\", \"nullable\"],\n      value: [\"default\", \"strict\"]\n    };\n  }\n\n  // propName, method, key\n  logDetailed(label, ...values) {\n    const idObj = this.idObj \n    const matchIdList = this.config.logDetailed || []\n    if (!matchIdList.length) return\n    const found = matchIdList.find(matchIds => {\n      if (matchIds.key && idObj.key !== matchIds.key) return false\n      if (matchIds.propName && idObj.propName !== matchIds.propName) return false\n      if (matchIds.method && idObj.method !== matchIds.method) return false\n      return true\n    })    \n    found && this.logInfo(label, idObj, ...values)\n  }\n\n  valErrMessage(msgName) {\n    return this.errorMessageHandler.valErrMessage(msgName);\n  }\n\n  get aliasMap() {\n    return {\n      oneOf: \"oneOf\",\n      enum: \"oneOf\",\n      anyOf: \"oneOf\"\n      // ...\n    };\n  }\n}\n","import { TypeMatcher } from \"./types/_type-matcher\";\n\nexport class ErrorMessageHandler extends TypeMatcher {\n  constructor(typeHandler, config = {}) {\n    super(config);\n    this.typeHandler = typeHandler;\n    this.constraints = typeHandler.constraints;\n    this.errMessages = typeHandler.errMessages;\n    this.key = typeHandler.key;\n    this.type = typeHandler.type;\n    this.description = typeHandler.description\n    this.title = typeHandler.title\n  }\n\n  valErrMessage(msgName) {\n    const { constraints, description, title } = this;\n    const errMsg = this.errMessageFor(msgName);\n    return typeof errMsg === \"function\" ? errMsg(constraints, { description, title}) : errMsg;\n  }\n\n  errMessageFor(msgName) {\n    const { errMessages, key } = this;\n    const errMsg = errMessages[key];\n    return errMsg ? errMsg[msgName] : errMessages[`$${msgName}`];\n  }\n}\n","import * as yup from \"yup\";\nimport uniq from \"uniq\";\n\nclass ConvertYupSchemaError extends Error {}\n\nfunction isObjectType(obj) {\n  return obj === Object(obj);\n}\n\nimport { Base } from \"../base\";\nimport { createWhenCondition } from \"../../conditions\";\nimport { ConstraintBuilder } from \"../../constraint-builder\";\nimport { ErrorMessageHandler } from \"../../error-message-handler\";\n\nclass YupMixed extends Base {\n  constructor(opts = {}) {\n    super(opts.config);\n    this.init(opts)\n  }\n\n  init(opts) {\n    let { schema, key, value, config, entryHandler } = opts;\n    config = config || {};\n    schema = schema || {};\n    this.validateOnCreate(key, value, opts);\n    this.opts = opts\n    this.entryHandler = entryHandler\n    this.validator = this.getValidator()\n    this.key = key;\n    this.schema = schema;\n    this.properties = schema.properties || {};\n    this.value = value;\n    this.title = value.title\n    this.description = value.description\n    this.constraints = this.getConstraints();\n    this.format = value.format || this.constraints.format;\n    this.config = config || {};\n    this.type = this.baseType;\n    this.mixedConfig = this.config.mixedEnabled || {};\n    this.typeConfig = this.config[this.type] || {};    \n    this.errMessages = config.errMessages || {};\n    this.configureTypeConfig();\n    this.constraintsAdded = {};\n    this.base = this.getBase()\n  }\n\n  get builder() {\n    return this.entryHandler && this.entryHandler.builder\n  }\n\n  getBase() {\n    return this.customBaseValidator || this.validatorInstance;\n  }\n  \n  get customBaseValidator() {\n    return this.config.validatorFor && this.config.validatorFor(this.type)\n  }\n\n  getValidator() {\n    return this.opts.validator || this.config.validator || (this.builder && this.builder.validator) || yup;\n  }  \n\n  get baseType() {\n    return \"mixed\";\n  }\n\n  get validatorInstance() {\n    return this.validator.mixed();\n  }\n\n  configureTypeConfig() {\n    if (this.typeConfig.enabled || this.typeConfig.extends) return;\n    if (!this.typeConfig.convert) return;\n    this.typeConfig.extends = Object.keys(this.typeConfig.convert);\n  }\n\n  isRequired(value) {\n    value = value || this.value;\n    return value.required === true;\n  }\n\n  get mode() {\n    return this.config.mode || {};\n  }\n\n  get disableFlags() {\n    return [false, \"disabled\", \"no\", \"off\"];\n  }\n\n  get enableFlags() {\n    return [true, \"enabled\", \"yes\", \"on\"];\n  }\n\n  disabledMode(modeName) {\n    const modeEntry = this.mode[modeName];\n    return !!this.disableFlags.find(disable => modeEntry === disable);\n  }\n\n  enabledMode(modeName) {\n    const modeEntry = this.mode[modeName];\n    return !!this.enableFlags.find(disable => modeEntry === disable);\n  }\n\n  get shouldPreProcessValue() {\n    return !this.disabledMode(\"notRequired\");\n  }\n\n  preProcessedConstraintValue(value) {\n    if (!this.shouldPreProcessValue) return value;\n\n    if (!this.isRequired(value)) {\n      return {\n        ...value,\n        notRequired: true\n      };\n    }\n    return value;\n  }\n\n  set value(value) {\n    this._value = this.preProcessedConstraintValue(value);\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  initHelpers() {\n    const { config } = this;\n    const errorMessageHandlerFactoryFn =\n      this.config.createErrorMessageHandler || this.createErrorMessageHandler;\n\n    this.errorMessageHandler = errorMessageHandlerFactoryFn(this, config);\n\n    const constraintBuilderFactoryFn =\n      this.config.createConstraintBuilder || this.createConstraintBuilder;\n    this.constraintBuilder = constraintBuilderFactoryFn(this, config);\n\n    // rebind: ensure this always mapped correctly no matter context\n    this.rebind(\"addConstraint\", \"addValueConstraint\");\n  }\n\n  createConstraintBuilder(typeHandler, config = {}) {\n    return new ConstraintBuilder(typeHandler, config);\n  }\n\n  createErrorMessageHandler(typeHandler, config = {}) {\n    return new ErrorMessageHandler(typeHandler, config);\n  }\n\n  rebind(...methods) {\n    methods.map(name => {\n      const method = this[name];\n      this[name] = this.isFunctionType(method) ? method.bind(this) : method;\n    });\n  }\n\n  validateOnCreate(key, value, opts) {\n    if (!key) {\n      this.error(`create: missing key ${JSON.stringify(opts)}`);\n    }\n    if (!value) {\n      this.error(`create: missing value ${JSON.stringify(opts)}`);\n    }\n  }\n\n  // override for each type\n\n  get mixedEnabled() {\n    return (\n      this.mixedConfig.enabled || [\n        \"oneOf\",\n        \"notOneOf\",\n        \"when\",\n        \"nullable\",\n        \"isType\",\n        \"label\",\n        \"const\",\n        \"refValueFor\"\n      ]\n    );\n  }\n\n  // override for each type\n  get typeEnabled() {\n    return [];\n  }\n\n  get $typeExtends() {\n    if (!Array.isArray(this.typeConfig.extends)) return;\n    return uniq([...this.typeConfig.extends, ...this.typeEnabled]);\n  }\n\n  get configuredTypeEnabled() {\n    return Array.isArray(this.typeConfig.enabled)\n      ? this.typeConfig.enabled\n      : this.typeEnabled;\n  }\n\n  get $typeEnabled() {\n    return this.$typeExtends || this.configuredTypeEnabled;\n  }\n\n  get enabled() {\n    return [...this.mixedEnabled, ...this.$typeEnabled];\n  }\n\n  convertEnabled() {\n    this.enabled.map(name => {\n      const convertFn = this.convertFnFor(name);\n      if (convertFn) {\n        convertFn(this);\n      }\n    });\n  }\n\n  convertFnFor(name) {\n    return this.customConvertFnFor(name, this) || this.builtInConvertFnFor(name);\n  }\n\n  customConvertFnFor(name) {\n    const typeConvertMap = this.typeConfig.convert || {};\n    return typeConvertMap[name];\n  }\n\n  builtInConvertFnFor(name) {\n    return this[name].bind(this);\n  }\n\n  getConstraints() {\n    return this.config.getConstraints(this.value);\n  }\n\n  createSchemaEntry() {\n    return this.convert().base;\n  }\n\n  convert() {\n    this.initHelpers();\n    this.addMappedConstraints();\n    this.convertEnabled();\n    return this;\n  }\n\n  apply(fnName, ...fnArgs) {\n    if (typeof fnName !== 'string') {\n      throw new TypeError(`[Mixed] apply must take a method name available on the validator instance as first argument`)\n    }\n    this.base = (fnArgs && fnArgs.length && this.base[fnName](...fnArgs)) || this.base;\n    return this\n  }\n\n  applyArr(fnName, arrValue) {\n    if (typeof fnName !== 'string') {\n      throw new TypeError(`[Mixed] apply must take a method name available on the validator instance as first argument`)\n    }\n    this.base = (arrValue && arrValue.length && this.base[fnName](arrValue)) || this.base;\n    return this\n  }\n\n\n  addValueConstraint(propName, opts) {\n    const constraint = this.constraintBuilder.addValueConstraint(\n      propName,\n      opts\n    );\n    if (constraint) {\n      const { base } = constraint;\n      this.base = base;\n    }\n    return this;\n  }\n\n  addConstraint(propName, opts) {\n    if (!this.constraintBuilder) {\n      throw new Error(`[YupMixed] addConstraint: Missing constraintBuilder in ${this.constructor.name}`);\n    }\n    const constraint = this.constraintBuilder.addConstraint(propName, opts);\n    if (constraint) {\n      this.base = constraint;\n    }\n    return this;\n  }\n\n  addMappedConstraints() {\n    // contains different types of constraints (ie. name -> yup constraint function calls)\n    const keys = Object.keys(this.constraintsMap);\n    const fn = this.addMappedConstraint.bind(this);\n    keys.map(fn);\n    return this;\n  }\n\n  addMappedConstraint(key) {\n    const { constraintsMap } = this;\n    const constraintNames = constraintsMap[key];\n    const fnName = key === \"value\" ? \"addValueConstraint\" : \"addConstraint\";\n    const fn = this[fnName];\n    constraintNames.map(constraintName => {\n      fn(constraintName);\n    });\n  }\n\n  get constraintsMap() {\n    return {\n      simple: [\"required\", \"notRequired\", \"nullable\"],\n      value: [\"default\", \"strict\"]\n    };\n  }\n\n  refValueFor() {\n    let propRefName =\n      this.constraints.refValueFor\n    if (this.isNothing(propRefName)) return this;\n    this.logInfo(\"refValueFor\", { propRefName })\n    return this.apply('when', (propRefName, (refValueFor, field) =>\n      refValueFor ? field.required().oneOf([yup.ref(propRefName)]) : field\n    ))\n  }\n\n  oneOf() {\n    let values =\n      this.constraints.enum || this.constraints.oneOf || this.constraints.anyOf;\n    if (this.isNothing(values)) return this;\n    values = Array.isArray(values) ? values : [values];\n    const resolvedValues = this.resolveValues(values)\n    // using alias\n    const alias = [\"oneOf\", \"enum\", \"anyOf\"].find(key => {\n      return this.constraints[key] !== undefined;\n    });\n    return this.addConstraint(alias, { values: resolvedValues });\n  }\n\n  notOneOf() {\n    const { not, notOneOf } = this.constraints;\n    let values = notOneOf || (not && (not.enum || not.oneOf));\n    if (this.isNothing(values)) return this;\n    values = Array.isArray(values) ? values : [values];\n    const resolvedValues = this.resolveValues(values)\n    return this.addConstraint(\"notOneOf\", { values: resolvedValues });\n  }\n\n  resolveValues(values) {\n    const schemaValues = values\n    return schemaValues.map(value => {\n      return this.isObjectType(value) ? resolveValue(value) : value\n    })\n  }  \n\n  const() {\n    let value =this.constraints.const\n    if (this.isNothing(value)) return this;\n    // TODO: resolve const data ref if valid format\n    if (this.isDataRef(value)) {\n      const dataRefPath = this.normalizeDataRefPath(value)\n      value = yup.ref(dataRefPath)\n    }    \n    return this.addConstraint('const', { value });\n  }\n\n  // TODO: investigate yup.ref\n  normalizeDataRefPath(value) {\n    value = value.$data || value\n    // remove first part before /\n    const parts = value.split('/').shift()\n    return parts.join('/')\n  }\n\n  isDataRef(value) {\n    return this.isPresent(value.$data)\n  }\n\n  resolveValue(value) {\n    const { createYupSchemaEntry } = this.config\n    const opts = { schema: this.schema, key: this.key, value, config: this.config }\n    return createYupSchemaEntry(opts)  \n  }\n\n  valErrMessage(msgName) {\n    return this.errorMessageHandler.valErrMessage(msgName);\n  }\n\n  createWhenConditionFor(when) {\n    const opts = {\n      key: this.key,\n      type: this.type,\n      value: this.value,\n      schema: this.schema,\n      properties: this.properties,\n      config: this.config,\n      when\n    };\n\n    const $createWhenCondition =\n      this.config.createWhenCondition || createWhenCondition;\n\n    return $createWhenCondition(opts);\n  }\n\n  label() {\n    const value = this.value\n    const label = value.title || value.label\n    this.base = (label && this.base.label(label)) || this.base\n    return this\n  }  \n\n  when() {\n    const when = this.constraints.when;\n    if (!isObjectType(when)) return this;\n    const { constraint } = this.createWhenConditionFor(when);\n\n    if (!constraint) {\n      this.warn(`Invalid when constraint for: ${when}`);\n      return this;\n    } else {\n      this.logInfo(`Adding when constraint for ${this.key}`, constraint);\n      // use buildConstraint or addConstraint to add when constraint (to this.base)\n\n      this.addConstraint(\"when\", { values: constraint, errName: \"when\" });\n    }\n    return this;\n  }\n\n  isType() {\n    const value = this.constraints.isType;\n    this.addConstraint(\"isType\", { value, errName: \"notOneOf\" });\n    return this;\n  }\n\n  nullable() {\n    const { nullable, isNullable } = this.constraints;\n    const value = nullable || isNullable;\n    this.addConstraint(\"nullable\", { value, errName: \"notOneOf\" });\n    return this;\n  }\n\n  message() {\n    return config.messages[this.key] || config.messages[this.type] || {};\n  }\n\n  errMessage(errKey = \"default\") {\n    return this.message[errKey] || \"error\";\n  }\n\n  toValidJSONSchema() {}\n\n  normalize() {}\n\n  deNormalize() {}\n\n  errorMsg(msg) {\n    this.throwError(msg);\n  }\n\n  error(name, msg) {\n    const label = `[${name}]`;\n    const fullMsg = [label, msg].join(\" \");\n    this.errorMsg(fullMsg);\n  }\n\n  // throw ConvertYupSchemaError(fullMsg);\n  throwError(msg) {\n    throw msg;\n  }\n}\n\nexport { YupMixed, ConvertYupSchemaError };\n","export const errValKeys = [\n  \"oneOf\",\n  \"enum\",\n  \"required\",\n  \"notRequired\",\n  \"minDate\",\n  \"min\",\n  \"maxDate\",\n  \"max\",\n  \"trim\",\n  \"lowercase\",\n  \"uppercase\",\n  \"email\",\n  \"url\",\n  \"minLength\",\n  \"maxLength\",\n  \"pattern\",\n  \"matches\",\n  \"regex\",\n  \"integer\",\n  \"positive\",\n  \"minimum\",\n  \"maximum\"\n];\n\nexport const defaults = {\n  errMessages: (keys = errValKeys) =>\n    keys.reduce((acc, key) => {\n      const fn = ({ key, value }) =>\n        `${key}: invalid for ${value.name || value.title}`;\n      acc[key] = fn;\n      return acc;\n    }, {})\n};\n","// See:\n// http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.4\n\nimport { YupMixed } from \"../mixed\";\n\nexport class YupArray extends YupMixed {\n  constructor(obj) {\n    super(obj);\n    this.type = this.baseType;\n    this.base = this.validatorInstance;\n    this.createYupSchemaEntry = this.config.createYupSchemaEntry;\n  }\n\n  get baseType() {\n    return \"array\";\n  }\n\n  get validatorInstance() {\n    return this.validator.array();\n  }\n\n  static create(obj) {\n    return new YupArray(obj);\n  }\n\n  convert() {\n    super.convert();\n    return this;\n  }\n\n  get typeEnabled() {\n    return [\"maxItems\", \"minItems\", \"ensureItems\", \"compact\", \"itemsOf\"];\n  }\n\n  ensureItems() {\n    return this.addConstraint(\"ensure\");\n  }\n\n  compact() {\n    return this.addConstraint(\"compact\");\n  }\n\n  itemsOf() {\n    const { items, itemsOf } = this.constraints;\n    const $of = items || itemsOf || this.constraints.of;\n\n    if (this.isNothing($of)) return;\n\n    if (Array.isArray($of)) {\n      this.error(\"itemsOf\", \"does not (yet) support an Array of schemas\");\n      return;\n    }\n\n    if (!this.isObjectType($of)) {\n      this.error(\"itemsOf\", `must be a schema object, was ${typeof $of}`);\n      return;\n    }\n\n    if (!this.createYupSchemaEntry) {\n      this.warn(\n        \"missing createYupSchemaEntry in config, needed for recursive validation\"\n      );\n      return;\n    }\n\n    try {\n      const schemaConf = {\n        key: this.key,\n        value: $of,\n        config: this.config\n      };\n\n      const schemaEntry = this.createYupSchemaEntry(schemaConf);\n\n      return this.addConstraint(\"of\", {\n        constraintValue: schemaEntry,\n        propValue: $of\n      });\n    } catch (ex) {\n      this.error(\"itemsOf: Error\", ex);\n    }\n    return this;\n  }\n\n  maxItems() {\n    const { maxItems, max } = this.constraints;\n    const $max = maxItems || max;\n    if (!this.isNumberType($max)) {\n      return this;\n    }\n    if (!this.isValidSize($max)) {\n      return this.handleInvalidSize(\"maxItems\", $max);\n    }\n    const newBase = $max && this.base.max($max);\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  minItems() {\n    const { minItems, min } = this.constraints;\n    const $min = minItems || min;\n    if (!this.isNumberType($min)) {\n      return this;\n    }\n    if (!this.isValidSize($min)) {\n      return this.handleInvalidSize(\"minItems\", $min);\n    }\n    const newBase = $min && this.base.min($min);\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  $items() {\n    return this;\n  }\n\n  $additionalItems() {\n    return this;\n  }\n\n  $uniqueItems() {\n    return this;\n  }\n\n  $contains() {\n    return this;\n  }\n\n  // utility\n\n  handleInvalidSize(name, value) {\n    const msg = `invalid array size constraint for ${name}, was ${value}. Must be a number >= 0`;\n    if (this.config.warnOnInvalid) {\n      this.warn(msg);\n      return this;\n    }\n    this.error(msg, value);\n    return this;\n  }\n\n  isValidSize(num) {\n    return this.isNumberType(num) && num >= 0;\n  }\n}\n","import { YupArray } from \"./array\";\nimport { Base } from \"../base\";\n\nexport class ArrayHandler extends Base {\n  constructor(config) {\n    super(config);\n  }\n\n  isArray(obj) {\n    if (!this.config.isArray) {\n      this.error(\"ArrayHandler: mising isArray in config\", this.config);\n    }\n    return this.config.isArray(obj);\n  }\n\n  handle(obj) {\n    return this.isArray(obj) && YupArray.create(obj).createSchemaEntry();\n  }\n}\n","import { ArrayHandler } from \"./handler\";\n\nexport function toYupArray(obj, config = {}) {\n  return obj && new ArrayHandler(config).handle(obj);\n}\n\nexport { YupArray } from \"./array\";\n","import { YupMixed } from \"../mixed\";\n\nexport class YupBoolean extends YupMixed {\n  constructor(obj) {\n    super(obj);\n    this.type = this.baseType;\n    this.base = this.validatorInstance;\n  }\n\n  get baseType() {\n    return \"boolean\";\n  }\n\n  get validatorInstance() {\n    return this.validator.boolean();\n  }\n\n  static create(obj) {\n    return new YupBoolean(obj);\n  }\n}\n","import { YupBoolean } from \"./boolean\";\n\nexport class BooleanHandler {\n  constructor(config) {\n    this.config = config;\n  }\n\n  isBoolean(obj) {\n    return this.config.isBoolean(obj);\n  }\n\n  handle(obj) {\n    return this.isBoolean(obj) && YupBoolean.create(obj).createSchemaEntry();\n  }\n}\n","import { BooleanHandler } from \"./handler\";\n\nexport function toYupBoolean(obj, config = {}) {\n  return obj && new BooleanHandler(config).handle(obj);\n}\n\nexport { YupBoolean } from \"./boolean\";\n","import { TypeMatcher } from '../_type-matcher';\n\nclass Constraint extends TypeMatcher {\n  constructor(typeHandler, map) {\n    super(typeHandler.config);\n    this.map = map || this.$map || {};\n    this.typeHandler = typeHandler;\n    this.delegates.map(name => {\n      const delegate = typeHandler[name];\n      if (!delegate) {\n        this.error(`missing delegate: ${name}`, {\n          typeHandler\n        });\n      }\n      this[name] = this.isFunctionType(delegate)\n        ? delegate.bind(typeHandler)\n        : delegate;\n    });\n  }\n\n  isStringType(val) {\n    return typeof val === \"string\";\n  }\n\n  get delegates() {\n    return [\"constraints\", \"addConstraint\", \"constraintsAdded\"];\n  }\n\n  add() {\n    const $map = this.map;\n    Object.keys($map).map(yupMethod => {\n      const names = this.entryNames($map[yupMethod]);\n      this.addConstraints(yupMethod, names);\n    });\n  }\n\n  entryNames(entry) {\n    return Array.isArray(entry) ? entry : [entry];\n  }\n\n  addConstraints(method, names = []) {\n    names.map(name => {\n      const value = this.validateAndTransform(name);\n      this.addConstraint(name, { method, value });\n    });\n    return this;\n  }\n\n  validateAndTransform(name) {\n    const cv = this.constraints[name];\n    this.validate(cv);\n    return this.transform(cv);\n  }\n\n  invalidMsg(name, value) {\n    return `invalid constraint for ${name}, was ${value}.`;\n  }\n\n  get explainConstraintValidMsg() {\n    return \"\";\n  }\n\n  invalidConstraintMsg(name, value) {\n    return [this.invalidMsg(name, value), this.explainConstraintValidMsg].join(\n      \"\\n\"\n    );\n  }\n\n  validate(cv) {\n    if (this.isNothing(cv)) {\n      return this;\n    }\n    if (!this.isValidConstraint(cv)) {\n      return this.handleInvalidConstraint(name, cv);\n    }\n  }\n\n  // override\n  isValidConstraint(value) {\n    return true;\n  }\n\n  handleInvalidConstraint(name, value) {\n    const msg = this.invalidConstraintMsg(name, value);\n    if (this.config.warnOnInvalid) {\n      this.warn(msg);\n      return this;\n    }\n    this.error(msg, value);\n    return this;\n  }\n}\n\nexport {\n  Constraint\n};\n","import { Constraint } from '../constraints/base';\n\nfunction createNumericConstraint(typer) {\n  return new NumericConstraint(typer);\n}\n\nclass NumericConstraint extends Constraint {\n  constructor(typeHandler) {\n    super(typeHandler);\n  }\n\n  transform(value) {\n    return this.typeHandler.toNumber(value);\n  }\n\n  isValidConstraint(value) {\n    return this.typeHandler.isNumberLike(value);\n  }\n\n  get explainConstraintValidMsg() {\n    return `Must be a number or convertible to a number`;\n  }\n}\n\nexport {\n  createNumericConstraint,\n  NumericConstraint\n};\n","import { NumericConstraint } from '../constraints/numeric';\n\nfunction createRangeConstraint(typer) {\n  return new RangeConstraint(typer);\n}\n\nclass RangeConstraint extends NumericConstraint {\n  constructor(typer) {\n    super(typer);\n  }\n\n  get $map() {\n    return {\n      moreThan: [\"exclusiveMinimum\", \"moreThan\"],\n      lessThan: [\"exclusiveMaximum\", \"lessThan\"],\n      max: [\"maximum\", \"max\"],\n      min: [\"minimum\", \"min\"]\n    };\n  }\n}\n\nexport {\n  createRangeConstraint,\n  RangeConstraint\n};\n","import { Base } from './base';\n\nclass Guard extends Base {\n  constructor(obj, config) {\n    super(config);\n    this.obj = obj;\n  }\n\n  isValid() {\n    return false;\n  }\n\n  verify() {\n    return this.isPresent(this.obj) && this.isValid(this.obj);\n  }\n}\n\nexport {\n  Guard\n};\n","import { Guard } from '../_guard';\n\nclass NumberGuard extends Guard {\n  constructor(obj, config) {\n    super(obj, config);\n  }\n\n  isValid() {\n    return this.config.isNumber(this.obj);\n  }\n}\n\nfunction createNumberGuard(obj, config) {\n  return new NumberGuard(obj, config);\n}\n\nexport {\n  createNumberGuard,\n  NumberGuard\n};\n","import { YupMixed } from \"../mixed\";\nimport { createRangeConstraint, RangeConstraint } from \"./range-constraint\";\nimport { createNumberGuard, NumberGuard } from \"./guard\";\n\nconst proceed = (obj, config = {}) => {\n  return createNumberGuard(obj, config).verify();\n};\n\nfunction toYupNumber(obj, config = {}) {\n  return proceed(obj, config) && buildYupNumber(obj);\n}\n\nfunction toYupNumberSchemaEntry(obj, config = {}) {\n  return proceed(obj, config) && buildSchemaEntry(obj);\n}\n\nfunction buildSchemaEntry(obj) {\n  return YupNumber.schemaEntryFor(obj);\n}\n\nfunction buildYupNumber(obj) {\n  return YupNumber.create(obj);\n}\n\nclass YupNumber extends YupMixed {\n  constructor(obj) {\n    super(obj);\n    this.type = this.baseType;\n    this.base = this.validatorInstance;\n    this.rangeConstraint = createRangeConstraint(this);\n  }\n\n  get baseType() {\n    return this.normalizeNumType(this.opts.type);\n  }\n\n  get validatorInstance() {\n    return this.validator.number();\n  }\n\n  normalizeNumType(type) {\n    return type === \"int\" ? \"integer\" : type;\n  }\n\n  static create(obj) {\n    return new YupNumber(obj);\n  }\n\n  static schemaEntryFor(obj) {\n    return YupNumber.create(obj).createSchemaEntry();\n  }\n\n  get typeEnabled() {\n    return [\"range\", \"posNeg\", \"integer\"];\n  }\n\n  convert() {\n    super.convert();\n    return this;\n  }\n\n  range() {\n    this.rangeConstraint.add();\n  }\n\n  truncate() {\n    return this.addConstraint(\"truncate\");\n  }\n\n  round() {\n    const { round } = this.constraints;\n    if (this.isNothing(round)) {\n      return this;\n    }\n    const $round = this.isStringType(round) ? round : \"round\";\n    round && this.base.round($round);\n    return this;\n  }\n\n  posNeg() {\n    this.positive();\n    this.negative();\n  }\n\n  integer() {\n    this.isInteger && this.addConstraint(\"integer\");\n    return this;\n  }\n\n  get isInteger() {\n    return this.config.isInteger(this.type);\n  }\n\n  positive() {\n    return this.addConstraint(\"positive\");\n  }\n\n  negative() {\n    return this.addConstraint(\"negative\");\n  }\n\n  get isNegative() {\n    const { exclusiveMaximum, negative } = this.constraints;\n    if (negative) return true;\n    if (exclusiveMaximum === undefined) return false;\n    return exclusiveMaximum === 0;\n  }\n\n  get isPositive() {\n    const { exclusiveMinimum, positive } = this.constraints;\n    if (positive) return true;\n    if (exclusiveMinimum === undefined) return false;\n    return exclusiveMinimum === 0;\n  }\n\n  normalize() {\n    this.constraints.maximum = this.constraints.maximum || this.constraints.max;\n    this.constraints.minimum = this.constraints.minimum || this.constraints.min;\n  }\n}\n\nexport {\n  toYupNumber,\n  toYupNumberSchemaEntry,\n  YupNumber,\n  createNumberGuard,\n  NumberGuard,\n  RangeConstraint,\n  createRangeConstraint\n};\n","import { YupMixed } from \"../mixed\";\n\n// Allow recursive schema\nexport class YupObject extends YupMixed {\n  constructor(obj) {\n    super(obj);\n    this.type = this.baseType;\n    this.base = this.validatorInstance;\n    this.properties = this.value.properties;\n  }\n\n  get baseType() {\n    return \"object\";\n  }\n\n  get validatorInstance() {\n    return this.validator.object();\n  }\n\n  static create(obj) {\n    return new YupObject(obj);\n  }\n\n  get typeEnabled() {\n    return [\"noUnknown\", \"camelCase\", \"constantCase\"];\n  }\n\n  convert() {\n    if (!this.properties) return this;\n    super.convert();\n    // this.initHelpers();\n    // this.convertEnabled();\n\n    const schema = this.value;\n    const config = this.config;\n\n    // recursive definition\n    if (schema) {\n      if (!config.buildYup) {\n        this.error(\"convert\", \"Missing buildYup function from config\", config);\n      }\n\n      const yupSchema = this.config.buildYup(schema, config);\n      this.base = yupSchema;\n    }\n    return this;\n  }\n\n  camelCase() {\n    return this.addConstraint(\"camelCase\");\n  }\n\n  constantCase() {\n    return this.addConstraint(\"constantCase\");\n  }\n\n  noUnknown() {\n    const { noUnknown, propertyNames } = this.value;\n    const $names = noUnknown || propertyNames;\n    const newBase =\n      $names &&\n      this.base.noUnknown(\n        $names,\n        this.valErrMessage(\"propertyNames\") || this.valErrMessage(\"noUnknown\")\n      );\n    this.base = newBase || this.base;\n    return this;\n  }\n}\n","import { YupObject } from \"./object\";\n\nconst isObject = fieldDef => fieldDef && fieldDef.type === \"object\";\n\nexport class ObjectHandler {\n  constructor(config = {}) {\n    config = config || {};\n    config.isObject = config.isObject || isObject;\n    this.config = config;\n    this.schema = config.schema;\n  }\n\n  isObject(obj) {\n    return this.config.isObject(obj.value);\n  }\n\n  handle(obj) {\n    return (\n      this.isObject(obj) &&\n      YupObject.create({ ...obj, config: this.config }).createSchemaEntry()\n    );\n  }\n}\n\nexport function createObjectHandler(config = {}) {\n  return new ObjectHandler(config);\n}\n","import { ObjectHandler } from \"./handler\";\n\nexport function toYupObject(obj, config = {}) {\n  return obj && new ObjectHandler(config).handle(obj);\n}\n\nexport { ObjectHandler };\nexport { YupObject } from \"./object\";\n","import { YupMixed } from \"../mixed\";\n\nexport class YupString extends YupMixed {\n  constructor(obj) {\n    super(obj);\n    this.type = this.baseType;\n    this.base = this.validatorInstance;\n  }\n\n  get baseType() {\n    return \"string\";\n  }\n\n  get validatorInstance() {\n    return this.validator.string();\n  }\n\n\n  static create(obj) {\n    return new YupString(obj);\n  }\n\n  convert() {\n    super.convert();\n    return this;\n  }\n\n  get typeEnabled() {\n    return [\n      \"normalize\",\n      \"minLength\",\n      \"maxLength\",\n      \"pattern\",\n      \"lowercase\",\n      \"uppercase\",\n      \"email\",\n      \"url\",\n      \"genericFormat\"\n    ];\n  }\n\n  trim() {\n    return this.addConstraint(\"trim\");\n  }\n\n  lowercase() {\n    return this.addConstraint(\"lowercase\");\n  }\n\n  uppercase() {\n    return this.addConstraint(\"uppercase\");\n  }\n\n  genericFormat() {\n    if (!this.config.format === true) return;\n    const format = this.format;\n    if (this.validator.prototype[format]) {\n      this.addConstraint(this.format);\n    }\n  }\n\n  email() {\n    if (!this.isEmail) return this;\n    const constraintName = this.constraintNameFor(\"email\", \"format\");\n    const method = \"email\";\n    this.addConstraint(\"email\", {\n      constraintValue: true,\n      constraintName,\n      method,\n      errName: method\n    });\n    return this;\n  }\n\n  constraintNameFor(...names) {\n    return names.find(name => this.constraints[name]);\n  }\n\n  get isEmail() {\n    return this.constraints.email || this.format === \"email\";\n  }\n\n  url() {\n    if (!this.isUrl) return this;\n    const constraintName = this.constraintNameFor(\"url\", \"format\");\n    const method = \"url\";\n    this.addConstraint(\"url\", {\n      constraintValue: true,\n      constraintName,\n      method,\n      errName: method\n    });\n    return this;\n  }\n\n  get isUrl() {\n    return this.constraints.url || this.format === \"url\";\n  }\n\n  // todo: use NumericConstraint or RangeConstraint\n  minLength() {\n    const { minLength } = this.constraints;\n    const errMsg = this.valErrMessage(\"minLength\") || this.valErrMessage(\"min\");\n    const newBase = minLength && this.base.min(minLength, errMsg);\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  // todo: use NumericConstraint or RangeConstraint\n  maxLength() {\n    const { maxLength } = this.constraints;\n    const errMsg = this.valErrMessage(\"maxLength\") || this.valErrMessage(\"max\");\n    const newBase = maxLength && this.base.max(maxLength, errMsg);\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  pattern() {\n    const { pattern, flags } = this.constraints;\n    if (!pattern) {\n      return this;\n    }\n    const regex = new RegExp(pattern, flags);\n    const errMsg =\n      this.valErrMessage(\"pattern\") ||\n      this.valErrMessage(\"matches\") ||\n      this.valErrMessage(\"regex\");\n\n    const newBase = regex && this.base.matches(regex, errMsg);\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  normalize() {\n    this.constraints.pattern =\n      this.constraints.pattern ||\n      this.constraints.matches ||\n      this.constraints.regex;\n    this.constraints.maxLength =\n      this.constraints.maxLength || this.constraints.max;\n    this.constraints.minLength =\n      this.constraints.minLength || this.constraints.min;\n  }\n}\n","import { YupString } from \"./string\";\n\nexport class StringHandler {\n  constructor(config) {\n    this.config = config;\n  }\n\n  isString(obj) {\n    return this.config.isString(obj);\n  }\n\n  handle(obj) {\n    return (\n      this.isString(obj) &&\n      YupString.create({ config: this.config, ...obj }).createSchemaEntry()\n    );\n  }\n}\n","import { StringHandler } from \"./handler\";\n\nexport function toYupString(obj, config = {}) {\n  return obj && new StringHandler(config).handle(obj);\n}\n\nexport { YupString } from \"./string\";\n","import { YupMixed } from \"../mixed\";\n\nexport class YupDate extends YupMixed {\n  constructor(obj) {\n    super(obj);\n    this.type = this.baseType;\n    this.base = this.validatorInstance;\n  }\n\n  get baseType() {\n    return \"date\";\n  }\n\n  get validatorInstance() {\n    return this.validator.date();\n  }\n\n  static create(obj) {\n    return new YupDate(obj);\n  }\n\n  get typeEnabled() {\n    return [\"minDate\", \"maxDate\"];\n  }\n\n  convert() {\n    super.convert();\n    return this;\n  }\n\n  toDate(date) {\n    return new Date(date);\n  }\n\n  // Yup supports string | Date\n  // allow int (number of milliseconds from 1970) via transformToDate\n  isValidDateType(date) {\n    return this.isStringType(date) || this.isDateType(date);\n  }\n\n  isValidDate(date) {\n    if (!this.isValidDateType(date)) return false;\n    return this.isStringType(date) ? Boolean(Date.parse(date)) : true;\n  }\n\n  // optionally transform millisecs to Date value?\n  transformToDate(date) {\n    return this.isNumberType(date) ? new Date(date) : date;\n  }\n\n  minDate() {\n    const minDate = this.constraints.minDate || this.constraints.min;\n    if (this.isNothing(minDate)) {\n      return this;\n    }\n    const $minDate = this.transformToDate(minDate);\n    if (!this.isValidDateType($minDate)) {\n      return this.handleInvalidDate(\"minDate\", $minDate);\n    }\n    const newBase =\n      $minDate &&\n      this.base.min(\n        this.toDate($minDate),\n        this.valErrMessage(\"minDate\") || this.valErrMessage(\"min\")\n      );\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  maxDate() {\n    const maxDate = this.constraints.maxDate || this.constraints.max;\n    if (this.isNothing(maxDate)) {\n      return this;\n    }\n    const $maxDate = this.transformToDate(maxDate);\n    if (!this.isValidDateType($maxDate)) {\n      return this.handleInvalidDate(\"maxDate\", $maxDate);\n    }\n    const newBase =\n      $maxDate &&\n      this.base.max(\n        this.toDate($maxDate),\n        this.valErrMessage(\"maxDate\") || this.valErrMessage(\"max\")\n      );\n    this.base = newBase || this.base;\n    return this;\n  }\n\n  handleInvalidDate(name, value) {\n    const msg = `invalid constraint for ${name}, was ${value}. Must be a number, string (valid date format) or a Date instance`;\n    if (this.config.warnOnInvalid) {\n      this.warn(msg);\n      return this;\n    }\n    this.error(msg, value);\n    return this;\n  }\n}\n","import { YupDate } from \"./date\";\n\nexport class DateHandler {\n  constructor(config) {\n    this.config = config;\n  }\n\n  isDate(obj) {\n    return this.config.isDate(obj);\n  }\n\n  handle(obj) {\n    return this.isDate(obj) && YupDate.create(obj).createSchemaEntry();\n  }\n}\n","import { DateHandler } from \"./handler\";\n\nexport function toYupDate(obj, config = {}) {\n  return obj && new DateHandler(config).handle(obj);\n}\n\nexport { YupDate } from \"./date\";\n","import { Base } from \"./types\";\n\nexport class PropertyValueResolverError extends Error {}\n\nexport class BasePropertyValueResolver extends Base {\n  constructor(opts, config, entryHandler) {\n    super(config);\n    const { value, type, kind, name, key, schema, types } = opts;\n    // this.logInfo('BasePropertyValueResolver', opts)\n    this.entryHandler = entryHandler || opts.entryHandler\n    this.builder = opts.builder\n    this.opts = opts;\n    this.kind = kind;\n    this.value = value;\n    this.schema = schema;\n    this.key = key;\n    this.value = value || {};\n    this.name = name;\n    this.type = type;\n    this.types = types;\n  }\n\n  get validator() {\n    return this.builder.validator\n  }\n\n  error(msg, data) {\n    const { opts } = this;\n    data ? console.error(msg, data, ...opts) : console.error(msg, ...opts);\n    throw new PropertyValueResolverError(msg);\n  }\n\n  resolve() {\n    throw \"Must be implemented by subclass\";\n  }\n\n  get obj() {\n    const { schema, key, value, type, kind, config, entryHandler } = this;\n    return {\n      schema,\n      key,\n      value,\n      type,\n      kind,\n      config,\n      entryHandler\n    };\n  }\n}\n","import { BasePropertyValueResolver } from \"./base-property-value-resolver\";\n\nexport const createMultiPropertyValueResolver = (opts, config) => {\n  return new MultiPropertyValueResolver(opts, config);\n};\n\nexport class MultiPropertyValueResolver extends BasePropertyValueResolver {\n  constructor(opts, config, entryHandler) {\n    super(opts, config, entryHandler);\n  }\n\n  resolve() {\n    const { value } = this;\n    if (!Array.isArray(value)) return;\n    const toMultiType = this.config.toMultiType;\n    if (toMultiType) {\n      return toMultiType(this);\n    }\n    return this.oneOf();\n  }\n\n  oneOf() {\n    const schemaValues = this.value\n    const createEntry = this.createEntry.bind(this)\n    const resolvedValidatorSchemas = schemaValues.map(createEntry)\n    return this.mixed().oneOf(resolvedValidatorSchemas)\n  }\n\n  createEntry(value) {\n    const { createYupSchemaEntry } = this.config\n    value = normalizedValue(value)\n    const opts = { schema: this.schema, key: this.key, value, config: this.config }\n    return createYupSchemaEntry(opts)\n  }\n\n  normalizedValue(value) {\n    return typeof value === 'string' ? {type: value}: value\n  }\n\n  mixed() {\n    return this.validator.mixed()\n  }\n}\n","import { BasePropertyValueResolver } from \"./base-property-value-resolver\";\n\nexport const createSinglePropertyValueResolver = (opts, config) => {\n  return new SinglePropertyValueResolver(opts, config);\n};\n\nexport class SinglePropertyValueResolver extends BasePropertyValueResolver {\n  constructor(opts, config, entryHandler) {\n    super(opts, config, entryHandler);\n  }\n\n  resolve() {\n    const { value } = this;\n    if (Array.isArray(value)) return;\n    const toSingleType = this.config.toSingleType;\n    if (toSingleType) {\n      return toSingleType(this);\n    }\n\n    const { obj, config, entryHandler } = this;\n    const typeHandlerNames = Object.keys(this.types);\n    let result;\n    // iterate all registered type handlers in this.types\n    for (let typeName of typeHandlerNames) {\n      const typeFn = this.types[typeName];\n      if (typeFn) {\n        result = typeFn(obj, config, entryHandler);\n      }\n      if (result) break;\n    }\n    return result;\n  }\n}\n","import { BasePropertyValueResolver } from \"./base-property-value-resolver\";\nimport { MultiPropertyValueResolver } from \"./multi-property-value-resolver\";\nimport { SinglePropertyValueResolver } from \"./single-property-value-resolver\";\n\nexport const createPropertyValueResolver = (opts, config, entryHandler) => {\n  return new PropertyValueResolver(opts, config, entryHandler);\n};\n\nexport class PropertyValueResolver extends BasePropertyValueResolver {\n  constructor(opts, config, entryHandler) {\n    super(opts, config, entryHandler);\n    this.initResolvers();\n  }\n\n  initResolvers() {\n    const { opts, config, entryHandler } = this;\n    const createMultiTypeResolverFn =\n      config.createMultiTypeResolver || this.createMultiTypeResolver.bind(this);\n    this.multiTypeResolver = createMultiTypeResolverFn(opts, config, entryHandler);\n    const createSingleTypeResolverFn =\n      config.createSingleTypeResolver ||\n      this.createSingleTypeResolver.bind(this);\n    this.singleTypeResolver = createSingleTypeResolverFn(opts, config, entryHandler);\n  }\n\n  createMultiTypeResolver() {\n    const { opts, config, entryHandler } = this;\n    return new MultiPropertyValueResolver(opts, config, entryHandler);\n  }\n\n  createSingleTypeResolver() {\n    const { opts, config, entryHandler } = this;\n    return new SinglePropertyValueResolver(opts, config, entryHandler);\n  }\n\n  resolve() {\n    return this.toMultiType() || this.toSingleType() || this.toDefaultEntry();\n  }\n\n  toMultiType() {\n    const resolve =\n      this.config.toMultiType ||\n      this.singleTypeResolver.resolve.bind(this.singleTypeResolver);\n    return resolve(this);\n  }\n\n  toSingleType() {\n    const resolve =\n      this.config.toSingleType ||\n      this.singleTypeResolver.resolve.bind(this.singleTypeResolver);\n    return resolve(this);\n  }\n\n  toDefaultEntry() {\n    return this.defaultType();\n  }\n\n  defaultType() {\n    this.error(\"toEntry: unknown type\", this.type);\n  }\n}\n","import {\n  Base,\n  toYupString,\n  toYupNumberSchemaEntry,\n  toYupBoolean,\n  toYupArray,\n  toYupObject,\n  toYupDate\n} from \"./types\";\n\nimport { createPropertyValueResolver } from \"./property-value-resolver\";\n\nclass YupSchemaEntryError extends Error {}\n\nclass YupSchemaEntry extends Base {\n  constructor(opts) {\n    super(opts.config);\n    const { schema, name, key, value, config, builder } = opts;\n    this.builder = builder\n    this.opts = opts;\n    this.schema = schema;\n    this.key = key;\n    this.value = value || {};\n    this.config = config || {};\n    this.name = name;    \n    this.init()\n  }\n\n  get calcType() {\n    const { value } = this\n    return Array.isArray(value) ? \"array\" : value.type;\n  }\n\n  get calcKind() {\n    return this.type === \"array\" ? \"multi\" : \"single\";\n  }\n\n  init() {\n    this.type = this.calcType;    \n    this.kind = this.calcKind;\n    this.setTypeHandlers();\n    this.setPropertyHandler();\n  }\n\n  get validator() {\n    return this.builder && this.builder.validator\n  }\n\n  setPropertyHandler() {\n    const { config } = this\n    const opts = this.propertyHandlerOpts\n    const createPropertyValueHandlerFn =\n      config.createPropertyValueHandler || this.createPropertyValueHandler;\n    this.propertyValueHandler = createPropertyValueHandlerFn(opts, config);\n  }\n\n  get propertyHandlerOpts() {\n    const { types, value, name, key, type, kind, schema } = this;\n    return {\n      type,\n      kind,\n      types,\n      value,\n      name,\n      key,\n      schema,\n      entryHandler: this\n    };\n  }\n\n  createPropertyValueHandler(opts, config) {\n    return createPropertyValueResolver(opts, config, this);\n  }\n\n  get defaultTypeHandlerMap() {\n    return {\n      string: toYupString,\n      number: toYupNumberSchemaEntry,\n      boolean: toYupBoolean,\n      array: toYupArray,\n      object: toYupObject,\n      date: toYupDate\n    };\n  }\n\n  setTypeHandlers() {\n    this.types = this.config.types || this.typeHandlers\n  }\n\n  get typeHandlers() {\n    return {\n      ...this.defaultTypeHandlerMap,\n      ...(this.config.typeHandlers || {})\n    };\n  }\n\n  isValidSchema() {\n    const { type } = this;\n    return this.isStringType(type);\n  }\n\n  error(msg, data) {\n    const { opts } = this;\n    data ? console.error(msg, data, ...opts) : console.error(msg, ...opts);\n    throw new YupSchemaEntryError(msg);\n  }\n\n  toEntry() {\n    if (!this.isValidSchema()) {\n      const schema = JSON.stringify(this.schema);\n      this.error(\n        `Not a valid schema: type ${\n          this.type\n        } must be a string, was ${typeof this.type} ${schema}`\n      );\n    }\n    const { opts, config } = this;\n    return this.propertyValueHandler.resolve(opts, config);\n  }\n}\n\nexport { YupSchemaEntryError, YupSchemaEntry, Base };\n","import { YupSchemaEntry } from \"./entry\";\n\nfunction createYupSchemaEntry(opts = {}) {\n  // const { schema, name, key, value, config } = opts;\n  return new YupSchemaEntry(opts).toEntry();\n}\n\nexport { createYupSchemaEntry };\n","import * as yup from \"yup\";\nimport { Base } from \"./entry\";\nimport { createYupSchemaEntry } from \"./create-entry\";\n\nfunction isObject(type) {\n  return type && type === \"object\";\n}\n\nexport function buildYup(schema, config = {}) {\n  return new YupBuilder(schema, {...config}).yupSchema;\n}\n\nfunction isObjectType(obj) {\n  return obj === Object(obj);\n}\n\nexport class YupBuilder extends Base {\n  constructor(schema, config = {}) {\n    super(config);\n    this.init(schema, config);\n  }\n\n  init(schema, config) {\n    config.buildYup = buildYup;\n    config.createYupSchemaEntry =\n      config.createYupSchemaEntry || createYupSchemaEntry;\n    this.config = Object.assign(this.config, config);    \n    this.schema = schema;\n    const type = this.getType(schema);\n    const props = this.getProps(schema);\n    this.type = type;\n    this.properties = props;\n    this.additionalProps = this.getAdditionalProperties(schema);\n    this.required = this.getRequired(schema);\n\n    this.setLocale()\n\n    const customInitFn = typeof config.init === 'function' ? config.init : () => {}\n    const customInit = customInitFn.bind(this) \n    customInit(schema, config)\n\n    if (!isObject(type)) {\n      this.error(`invalid schema: must be type: \"object\", was type: ${type}`);\n      return;\n    }\n\n    if (!isObjectType(props)) {\n      const props = JSON.stringify(properties);\n      this.error(`invalid schema: must have a properties object: ${props}`);\n      return;\n    }\n\n    const name = this.getName(schema);\n    const properties = this.normalizeRequired(schema);\n    const shapeConfig = this.propsToShape({ properties, name, config });\n\n    this.shapeConfig = shapeConfig;\n    this.validSchema = true;\n  }\n\n  get validator() {\n    return yup\n  }\n\n  setLocale() {\n    this.config.locale && yup.setLocale(this.config.locale);\n  }\n\n  getAdditionalProperties(schema) {\n    return schema.additionalProperties;\n  }\n\n  getRequired(obj) {\n    const { getRequired } = this.config;\n    return getRequired ? getRequired(obj) : obj.required || [];\n  }\n\n  getProps(obj) {\n    return this.config.getProps(obj);\n  }\n\n  getType(obj) {\n    return this.config.getType(obj);\n  }\n\n  getName(obj) {\n    return this.config.getName(obj);\n  }\n\n  get yupSchema() {\n    return yup.object().shape(this.shapeConfig);\n  }\n\n  normalizeRequired() {\n    const properties = {\n      ...this.properties\n    };\n    const required = [...this.required] || [];\n    // this.logInfo(\"normalizeRequired\", {\n    //   properties,\n    //   required\n    // });\n    const propKeys = Object.keys(properties);\n    return propKeys.reduce((acc, key) => {\n      // this.logInfo(\"normalizeRequired\", {\n      //   key\n      // });\n      const value = properties[key];\n      const isRequired = required.indexOf(key) >= 0;\n      if (isObjectType(value)) {\n        value.required = this.isRequired(value) || isRequired;\n      } else {\n        this.warn(`Bad value: ${value} must be an object`);\n      }\n\n      acc[key] = value;\n      return acc;\n    }, {});\n  }\n\n  isRequired(value) {\n    return this.config.isRequired(value);\n  }\n\n  propsToShape(opts = {}) {\n    const shape = this.objPropsToShape(opts);\n    this.objPropsShape = shape;\n    this.addPropsShape = this.additionalPropsToShape(opts, shape);\n    return shape;\n  }\n\n  additionalPropsToShape(opts, shape) {\n    return shape;\n  }\n\n  objPropsToShape({ name }) {\n    const properties = {\n      ...this.properties\n    };\n    const keys = Object.keys(properties);\n    return keys.reduce((acc, key) => {\n      const value = properties[key];\n      const yupSchemaEntry = this.propToYupSchemaEntry({\n        name,\n        key,\n        value\n      });\n      this.logInfo(\"propsToShape\", { key, yupSchemaEntry });\n      acc[key] = yupSchemaEntry;\n      return acc;\n    }, {});\n  }\n\n  propToYupSchemaEntry({ name, key, value = {} }) {\n    return this.createYupSchemaEntry({\n      schema: this.schema,\n      name,\n      key,\n      value,\n      config: this.config,\n      builder: this\n    });\n  }\n\n  createYupSchemaEntry(opts = {}) {\n    return this.config.createYupSchemaEntry(opts);\n  }\n\n  onConstraintAdded(constraint) {\n    this.logInfo('Constraint Added', constraint)\n  }\n}","// - `alpha-numeric`\n// - `alpha`\n// - `ascii`\n// - `byte`\n// - `credit-card`\n// - `currency-amount`\n// - `data-uri`\n// - `date-time`\n// - `date`\n// - `domain-name`\n// - `email`\n// - `hash`\n// - `hex-color`\n// - `ipv4`\n// - `ipv6`\n// - `isbn`\n// - `magnet-uri`\n// - `mime-type`\n// - `mobile-phone`\n// - `mongo-id`\n// - `postal-code`\n// - `uri`\n// - `uuid`\n\n// const validator = require(\"validator\");\nimport dashify from 'dashify';\n\n//const camelCase = require(\"camelcase\");\nimport camelCase from 'uppercamelcase';\n\nimport { addMethod, string } from 'yup';\n\nconst toConstraintsMap = (values, opts = {}) => {\n  return values.reduce((acc, value) => {\n    if (typeof value !== \"string\" && !(value instanceof Object)) {\n      if (opts.throws !== false) {\n        throw `toConstraintsMap: invalid entry ${value}`;\n      } else {\n        return acc;\n      }\n    }\n    if (typeof value === \"string\") {\n      acc[name] = {};\n    } else {\n      if (!value.name) {\n        if (opts.throws !== false) {\n          throw `toConstraintsMap: invalid entry ${value} missing name`;\n        } else {\n          return acc;\n        }\n      }\n      acc[value.name] = value;\n    }\n    return acc;\n  }, {});\n};\n\n// const defaultConstraints = [\n//   'ascii',\n//   {\n//     name: alphanumeric,\n//     optsKey: \"locale\"\n//   },\n//   // ...\n// ]\n\nconst defaultConstraints = {\n  alphanumeric: {\n    optsKey: \"locale\"\n  },\n  alpha: {\n    optsKey: \"locale\"\n  },\n  ascii: {},\n  byte: {},\n  creditCard: {},\n  currency: {\n    opts: \"currencyOpts\"\n  },\n  dataUri: {},\n  dateTime: {},\n  date: {},\n  domainName: {\n    opts: \"domainOpts\"\n  },\n  hash: {\n    opts: \"hashAlgo\"\n  },\n  hexColor: {},\n  ipv4: {},\n  ipv6: {},\n  isbn: {},\n  magnetUri: {},\n  mimeType: {},\n  mobilePhone: {},\n  mongoId: {},\n  postalCode: {},\n  uuid: {}\n};\n\n// Template:\n// Yup.addMethod(Yup.string, \"isHexColor\", function(args) {\n//   const { message } = args;\n//   return this.test(\"hex-color\", message, function(value) {\n//     const { path, createError } = this;\n//     // [value] - value of the property being tested\n//     // [path]  - property name,\n//     // ...\n//     return validator.isHexColor(value) || createError({ path, message });\n//   });\n// });\n\nconst defaults = {\n  createValidatorName: (validatorName, key) => {\n    const name = validatorName || key;\n    validatorName = camelCase(name);\n    validatorName = validatorName.replace(/Uri$/, \"URI\");\n    validatorName = validatorName.replace(/Id$/, \"ID\");\n    return `is${validatorName}`;\n  },\n  createTestName: (testName, key) => (testName = dashify(testName || key))\n};\n\nconst fallBackFnMap = {\n  isMagnetURI: (value, isMagnetUri) => {\n    return /magnet:\\?xt=urn:[a-z0-9]+:[a-z0-9]{32}/i.test(value);\n  }\n};\n\nfunction extendYupApi({\n  constraints,\n  override = false,\n  validator,\n  createValidatorName,\n  createTestName\n} = {}) {\n  if (!validator) {\n    throw \"extendYupApi: missing validator option\";\n  }\n\n  if (Array.isArray(constraints)) {\n    constraints = toConstraintsMap(constraints);\n  }\n\n  if (!override) {\n    constraints = {\n      ...defaultConstraints,\n      ...(constraints || {})\n    };\n  } else {\n    constraints = constraints || defaultConstraints;\n  }\n\n  createValidatorName = createValidatorName || defaults.createValidatorName;\n  createTestName = createTestName || defaults.createTestName;\n\n  Object.keys(constraints).map(key => {\n    let { testName, optsKey, validatorName, logging } = constraints[key];\n    const fullValidatorName = createValidatorName(validatorName, key);\n    testName = createTestName(testName, key);\n\n    // See https://github.com/jquense/yup#yupaddmethodschematype-schema-name-string-method--schema-void\n    addMethod(string, key, (args = {}) => {\n      const { message } = args;\n      const opts = args[optsKey];\n      return string().test(testName, message, value => {\n        // return this.transform(value => {\n        const { path, createError } = this;\n        // [value] - value of the property being tested\n        // [path]  - property name,\n        // ...\n        let validatorFn = validator[fullValidatorName];\n        validatorFn = validatorFn || fallBackFnMap[fullValidatorName];\n\n        if (typeof validatorFn !== \"function\") {\n          throw Error(\"No method named ${validatorName} on validator\");\n        }\n        const valid = validatorFn(value, opts);\n        if (logging === true) {\n          console.log(\"Yup validator bridge\", {\n            key,\n            fullValidatorName,\n            testName,\n            value,\n            valid\n          });\n        }\n        return valid || createError({ path, message });\n      });\n    });\n  });\n}\n\nexport {\n  extendYupApi,\n  toConstraintsMap\n};\n"],"names":["defaults","getProps","obj","properties","getType","type","getName","name","title","getConstraints","isString","isArray","isInteger","isBoolean","hasDateFormat","find","t","format","isDate","isNumber","isObject","isRequired","required","typeDefConf","includes","value","_obj$value","fields","isFloat","isDouble","logicalType","jsonSchemaDefaults","avro","avroDefaults","TypeMatcher","constructor","config","this","log","error","enable","logging","console","err","errMsg","values","length","warn","warnMsg","logInfo","super","isNothing","val","isPresent","num","toNumber","Number","isNumberLike","isNaN","isObjectType","Object","isArrayType","Array","isNumberType","isStringType","isFunctionType","isDateType","Date","SchemaParserBuilder","schemaParserMap","lookup","build","entry","extends","result","extend","baseMap","Base","schemaParser","createSchemaParserBuilder","defaultSchemaParserMap","schemaType","WhenEntry","whenEntryObj","opts","schema","key","when","validateAndConfigure","whenEntryKeys","keys","hasKey","createYupSchemaEntry","createValue","entryObj","createEntryOpts","whenKey","createEntry","findKey","hasAnyKey","findKeys","whenEntryFor","whenObj","createEntryKey","entryDef","calcEntryObj","newEntry","msg","WhenCondition","validate","whenKeys","createWhenEntry","whenEntry","accumulate","acc","assign","constraintObj","reduce","bind","keyVal","constraintValue","constraint","createWhenCondition","ConstraintBuilder","typeHandler","builder","constraintsAdded","delegators","map","propName","constraintName","propValue","method","yup","errName","base","getFirstValue","constraints","idObj","logDetailed","resolved","yupConstraintMethodName","aliasMap","constraintFn","constraintErrMsg","valErrMessage","errErrMsg","constrOpts","errFn","constrainFnNames","newBase","fnName","potentialValues","isDefined","filter","nonPresentConstraintValue","onConstraintAdded","presentConstraintValue","isNoValueConstraint","multiValueConstraint","callConstraintFn","isMultiArgsCall","multiArgsValidatorMethods","noValueConstraints","addValueConstraint","addConstraint","constraintsMap","simple","label","matchIdList","matchIds","msgName","errorMessageHandler","oneOf","enum","anyOf","ErrorMessageHandler","errMessages","description","errMessageFor","ConvertYupSchemaError","Error","YupMixed","init","entryHandler","validateOnCreate","validator","getValidator","baseType","mixedConfig","mixedEnabled","typeConfig","configureTypeConfig","getBase","customBaseValidator","validatorInstance","validatorFor","mixed","enabled","convert","mode","disableFlags","enableFlags","disabledMode","modeName","modeEntry","disable","enabledMode","shouldPreProcessValue","preProcessedConstraintValue","notRequired","_value","initHelpers","createErrorMessageHandler","constraintBuilder","createConstraintBuilder","rebind","JSON","stringify","typeEnabled","$typeExtends","uniq","configuredTypeEnabled","$typeEnabled","convertEnabled","convertFn","convertFnFor","customConvertFnFor","builtInConvertFnFor","createSchemaEntry","addMappedConstraints","apply","fnArgs","TypeError","applyArr","arrValue","fn","addMappedConstraint","refValueFor","propRefName","field","ref","resolvedValues","resolveValues","alias","undefined","notOneOf","not","resolveValue","const","isDataRef","dataRefPath","normalizeDataRefPath","$data","split","shift","join","createWhenConditionFor","isType","nullable","isNullable","message","messages","errMessage","errKey","toValidJSONSchema","normalize","deNormalize","errorMsg","throwError","fullMsg","errValKeys","YupArray","array","static","ensureItems","compact","itemsOf","items","$of","of","schemaEntry","ex","maxItems","max","$max","isValidSize","handleInvalidSize","minItems","min","$min","$items","$additionalItems","$uniqueItems","$contains","warnOnInvalid","ArrayHandler","handle","create","toYupArray","YupBoolean","boolean","BooleanHandler","toYupBoolean","Constraint","$map","delegates","delegate","add","yupMethod","names","entryNames","addConstraints","validateAndTransform","cv","transform","invalidMsg","explainConstraintValidMsg","invalidConstraintMsg","isValidConstraint","handleInvalidConstraint","NumericConstraint","RangeConstraint","typer","moreThan","lessThan","Guard","isValid","verify","NumberGuard","proceed","createNumberGuard","toYupNumberSchemaEntry","YupNumber","schemaEntryFor","buildSchemaEntry","rangeConstraint","normalizeNumType","number","range","truncate","round","$round","posNeg","positive","negative","integer","isNegative","exclusiveMaximum","isPositive","exclusiveMinimum","maximum","minimum","YupObject","object","buildYup","yupSchema","camelCase","constantCase","noUnknown","propertyNames","$names","fieldDef","ObjectHandler","toYupObject","YupString","string","trim","lowercase","uppercase","genericFormat","prototype","email","isEmail","constraintNameFor","url","isUrl","minLength","maxLength","pattern","flags","regex","RegExp","matches","StringHandler","toYupString","YupDate","date","toDate","isValidDateType","isValidDate","Boolean","parse","transformToDate","minDate","$minDate","handleInvalidDate","maxDate","$maxDate","DateHandler","toYupDate","buildYupNumber","PropertyValueResolverError","BasePropertyValueResolver","kind","types","data","resolve","MultiPropertyValueResolver","toMultiType","schemaValues","resolvedValidatorSchemas","normalizedValue","SinglePropertyValueResolver","toSingleType","typeHandlerNames","typeName","typeFn","createPropertyValueResolver","PropertyValueResolver","initResolvers","createMultiTypeResolverFn","createMultiTypeResolver","multiTypeResolver","createSingleTypeResolverFn","createSingleTypeResolver","singleTypeResolver","toDefaultEntry","defaultType","YupSchemaEntryError","YupSchemaEntry","calcType","calcKind","setTypeHandlers","setPropertyHandler","propertyValueHandler","createPropertyValueHandler","propertyHandlerOpts","defaultTypeHandlerMap","typeHandlers","isValidSchema","toEntry","YupBuilder","props","additionalProps","getAdditionalProperties","getRequired","setLocale","customInit","normalizeRequired","shapeConfig","propsToShape","validSchema","locale","additionalProperties","shape","indexOf","objPropsToShape","objPropsShape","addPropsShape","additionalPropsToShape","yupSchemaEntry","propToYupSchemaEntry","defaultConstraints","alphanumeric","optsKey","alpha","ascii","byte","creditCard","currency","dataUri","dateTime","domainName","hash","hexColor","ipv4","ipv6","isbn","magnetUri","mimeType","mobilePhone","mongoId","postalCode","uuid","createValidatorName","validatorName","replace","createTestName","testName","dashify","fallBackFnMap","isMagnetURI","isMagnetUri","test","override","throws","toConstraintsMap","fullValidatorName","addMethod","args","path","createError","validatorFn","valid"],"mappings":"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"}